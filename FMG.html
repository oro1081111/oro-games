<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Four-Moves-Chess</title>
  <style>
    :root{
      --bg: #0b1020;
      --panel: #121a33;
      --panel-2:#0f1530;
      --text: #e9eefb;
      --muted:#9fb0d6;
      --accent:#6ee7ff;
      --accent-2:#7c5cff;
      --good:#00d18f;
      --bad:#ff5c7c;
      --red:#ff5a5a;
      --blue:#3fa6ff;
      --cell:#151f43;
      --cell-h:#1a2552;
      --cell-ring:#7dd3fc;
      --x:#6b7280;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 16px;
      --logh: 240px; /* æ—¥èªŒ/è¦å‰‡å›ºå®šé«˜åº¦ï¼Œèˆ‡æ£‹ç›¤è²¼é½Š */
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, "Noto Sans TC", "PingFang TC", "Microsoft JhengHei", sans-serif;
      background: radial-gradient(1200px 800px at 20% -10%, #1b2352 0%, #0b1020 45%, #070a15 100%);
      color:var(--text);
      letter-spacing:.2px;
    }
    .t-red{color:var(--red)}
    .t-blue{color:var(--blue)}
    .app{max-width:1100px;margin:32px auto;padding:0 16px;display:grid;grid-template-columns: 1fr 1fr;gap:20px;align-items:stretch}
    .card{background:linear-gradient(180deg, var(--panel) 0%, var(--panel-2) 100%); border:1px solid #1f2a52;border-radius:var(--radius); box-shadow:var(--shadow); overflow:hidden; display:flex; flex-direction:column; height:100%;}
    .header{padding:18px 22px; display:flex; align-items:center; justify-content:space-between; border-bottom:1px solid #24305f}
    .header h1{font-size:20px;margin:0; font-weight:700; letter-spacing:.4px}
    .header .sub{opacity:.8;font-size:12px}

    .board-wrap{padding:20px}
    .board{display:grid; grid-template-columns: repeat(4, 1fr); gap:10px; position:relative}
    .cell{position:relative; aspect-ratio:1 / 1; background:var(--cell); border:1px solid #283569; border-radius:12px; display:flex; align-items:center; justify-content:center; font-weight:800; font-size:28px; color:#dbe6ff; transition:transform .08s ease, background .15s ease, border-color .2s ease;}
    .cell:hover{background:var(--cell-h)}
    .cell.legal{outline: 3px solid var(--cell-ring); outline-offset: -3px; cursor:pointer; box-shadow: 0 0 0 2px rgba(125,211,252,.3) inset}
    .cell.X{background:transparent; border-color:transparent; color:transparent;}
    .piece{position:absolute; inset:12%; border-radius:50%; border:6px solid currentColor; background:transparent; box-shadow: 0 2px 10px rgba(0,0,0,.35), 0 0 0 2px rgba(255,255,255,0.04) inset; pointer-events:none}
    .piece.red{color:var(--red)}
    .piece.blue{color:var(--blue)}
    .piece.active{box-shadow: 0 0 0 3px rgba(255,255,255,0.15) inset, 0 0 0 8px rgba(125,211,252,0.22); animation:pulse 1.2s ease-in-out infinite}
    @keyframes pulse{0%{transform:scale(1)}50%{transform:scale(1.04)}100%{transform:scale(1)}}
    .anim-piece{position:absolute; border-radius:50%; border:6px solid currentColor; background:transparent; box-shadow: 0 2px 10px rgba(0,0,0,.35), 0 0 0 2px rgba(255,255,255,0.04) inset; pointer-events:none; transition: transform 160ms ease}
    .anim-piece.red{color:var(--red)}
    .anim-piece.blue{color:var(--blue)}
    .coords{position:absolute; bottom:6px; right:8px; font-size:10px; color:#94a3b8; opacity:.6}

    .panel{padding:16px 18px}
    .grid2{display:grid; grid-template-columns:1fr 1fr; gap:12px}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .row.nowrap{flex-wrap:nowrap}
    label{font-size:12px; color:var(--muted)}
    select,input,textarea,button{background:#0e1430; color:var(--text); border:1px solid #273163; border-radius:10px; padding:8px 10px; font-size:14px}
    input[type="number"]{width:120px}
    textarea{width:100%; height:110px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;}
    button{cursor:pointer; border:1px solid #394685; background:linear-gradient(180deg,#1a244e,#121a33); padding:10px 14px; font-weight:700}
    button.primary{background:linear-gradient(180deg, #2a76ff, #2356ce); border-color:#2d5fd1}
    button.ghost{background:transparent}

    .status{padding:10px 18px; display:flex; flex-wrap:wrap; gap:14px; border-top:1px solid #24305f}
    .pill{background:#0b1333; border:1px solid #24305f; padding:6px 10px; border-radius:999px; font-size:12px; color:#dbe6ff}
    .pill.good{border-color:#0a6b50; color:#9ef1d2}
    .pill.bad{border-color:#6b1a2a; color:#ffc4cf}

    /* Tabs (æ—¥èªŒ / è¦å‰‡) */
    .tabs{padding:10px 18px; display:flex; gap:10px; border-top:1px solid #24305f; background:#0a0f25}
    .tab{padding:8px 14px; border-radius:999px; border:1px solid #2b396e; background:#0b1333; color:#dbe6ff; cursor:pointer}
    .tab.active{background:#1b2a5a; border-color:#3a57a5}
    .tabwrap{flex:1 1 auto; display:flex; min-height:0}
    .log{padding:14px 18px; overflow:auto; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; background:#0a0f25; border-top:1px solid #24305f; border-bottom-left-radius:var(--radius); border-bottom-right-radius:var(--radius); flex:1 1 auto; min-height:0; height:auto}
    .log p{margin:6px 0}
    .rules{padding:16px 18px; overflow:auto; background:#0a0f25; border-top:1px solid #24305f; border-bottom-left-radius:var(--radius); border-bottom-right-radius:var(--radius); font-family: inherit; line-height:1.6; flex:1 1 auto; min-height:0; height:auto}

    .hint{font-size:12px; color:var(--muted); padding:0 18px 16px}
    .sep{height:1px;background:#24305f;margin:14px 0}
    .footer{padding:12px 18px; font-size:12px; color:#99a4c7; margin-top:auto}
  
/* ===== Responsive/mobile fixes ===== */
.app{display:grid; grid-template-columns: 1.2fr 450px; gap:16px; max-width:1200px; margin:0 auto; padding: max(12px, env(safe-area-inset-top)) 12px 12px 12px;}
@media (max-width: 900px){ .app{ grid-template-columns:1fr; } .right{ order:2; } .left{ order:1; } .panel{ width:100%; } }
.board{ max-width: min(92vw, 560px); margin:0 auto; position:relative; }
.cell{ aspect-ratio: 1 / 1; font-size: clamp(16px, 6vw, 28px); }
.piece, .anim-piece{ border-width: clamp(4px, 1vw, 6px); }
@media (max-width: 420px){ .board{ gap:8px; } .cell .coords{ display:none; } }
.right .card{ max-width:680px; margin:0 auto; }
.right textarea{ width:100%; min-height:120px; font-size:16px; }
.right select, .right input, .right button{ font-size:16px; }
#log{ max-height:none; overflow:auto; }
.board{ touch-action: manipulation; }
/* ===== end responsive tweaks ===== */
  /* ============== ç­‰é«˜è¨­å®šï¼šå³å´é«˜åº¦è·Ÿéš¨å·¦å´ï¼ˆæ¡Œæ©Ÿï¼‰ ============== */
.card.right{ height: var(--leftH, auto); }
@media (max-width: 900px){ .card.right{ height:auto; } }
  </style>
  <style>
    a { color: #6ee7ff; text-decoration: underline; }
    a:hover { color: #fff; }
  </style>
</head>
<body>
  <div class="app">
    <div class="card left">
      <div class="header">
        <h1>å››æ­¥æ£‹ Four-Moves-Chess</h1>
        <div class="sub">è¨­è¨ˆè€…:æœªçŸ¥</div>
      </div>
    <div class="board-wrap">
      <!-- å‹ç‡æ¢ -->
      <div class="winrate-bar" style="margin:0 0 8px 0;">
        <div class="bar" style="display:flex;height:18px;border-radius:8px;overflow:hidden;background:#1a2a1a;border:1px solid #273163;">
          <div id="barRed" style="background:#f87171;height:100%;transition:width .3s"></div>
          <div id="barBlue" style="background:#60a5fa;height:100%;transition:width .3s"></div>
        </div>
        <div class="labels" style="display:flex;justify-content:space-between;font-size:13px;margin-top:2px;">
          <span id="redRate" style="color:#f87171">ç´…æ–¹å‹ç‡50%</span>
          <span id="blueRate" style="color:#60a5fa">è—æ–¹å‹ç‡50%</span>
        </div>
      </div>
      <div id="board" class="board"></div>
    </div>
      <div class="hint" id="hint">ç´…è‰²ç©å®¶è«‹é»æ“Šä»»ä¸€é«˜äº®æ ¼è½å­</div>
    </div>

    <div class="card right">
      <div class="header">
        <h1>å°å±€è¨­å®š</h1>
        <div class="sub">éš¨æ©Ÿæˆ–æŒ‡å®šé–‹å±€ã€ç©å®¶/éš¨æ©Ÿ/AI</div>
      </div>
      <div class="panel">
        <div class="grid2">
          <div class="row">
            <label>ç´…æ–¹å…ˆæ‰‹</label>
            <select id="redType">
              <option value="human" selected>ç©å®¶</option>
              <option value="random">éš¨æ©Ÿ</option>
              <option value="ai">AI</option>
            </select>
          </div>
          <div class="row">
            <label>è—æ–¹å¾Œæ‰‹</label>
            <select id="blueType">
              <option value="human">ç©å®¶</option>
              <option value="random">éš¨æ©Ÿ</option>
              <option value="ai" selected>AI</option>
            </select>
          </div>
          <div class="row">
            <label>é–‹å±€è¨­ç½®</label>
            <select id="opening">
              <option value="random">éš¨æ©Ÿ</option>
              <option value="standard" selected>æ¨™æº–</option>
              <option value="same">ç›¸åŒ</option>
            </select>
          </div>
          <div class="row nowrap">
            <label for="iters">AIè¿­ä»£æ•¸</label>
            <input id="iters" type="number" min="100" step="100" value="2000" />
          </div>
        </div>
        <div class="sep"></div>
        <div class="row" style="gap:10px; justify-content:space-between">
          <button class="primary" id="btnStart">é–‹å§‹æ–°å°å±€</button>
          <button class="ghost" id="btnReset" onclick="window.location='index.html'">è¿”å›ä¸»é </button>
        </div>
      </div>

      <!-- Tabs: æ—¥èªŒ / è¦å‰‡ -->
      <div class="tabs">
        <button id="tabLog"   class="tab active" data-target="log">è¡Œå‹•æ—¥èªŒ</button>
        <button id="tabRules" class="tab"        data-target="rules">è¦å‰‡èªªæ˜</button>
        <button id="tabAbout" class="tab"        data-target="about">éŠæˆ²ä»‹ç´¹</button>
      </div>
      <div class="tabwrap">
        <div class="log" id="log"></div>
        <div class="rules" id="rules" style="display:none">
          <h3 style="margin:0 0 8px">éŠæˆ²è¦å‰‡</h3>
          <ol style="margin:0 0 8px 18px; padding:0">
            <li><b>ç”±ç´…è‰²ç©å®¶é–‹å§‹ï¼Œè¼ªæµé€²è¡Œå›åˆè¡Œå‹•</b>
                <li><b>å›åˆè¡Œå‹•</b>ï¼š
                  <ul style="margin:8px 0 8px 16px; padding:0">
                    <li>è‹¥æ‰€åœ¨æ ¼ç‚º <b>S</b>ï¼šå¯é¸æ“‡ <b>1ï½4</b> æ­¥ã€‚</li>
                    <li>è‹¥æ‰€åœ¨æ ¼ç‚ºæ•¸å­— <b>n</b>ï¼šé ˆèµ° <b>n</b> æ­¥ã€‚</li>
                    <li>ä¸Šä¸‹å·¦å³ç§»å‹•ï¼Œå¿…é ˆ<b>è·³é</b>æ‰€æœ‰<b>ç©ºæ ¼</b>èˆ‡<b>æ£‹å­</b>ã€‚</li>
                    <li>ä¸å¯åœç•™åœ¨è©²å›åˆç¶“éçš„æ ¼å­ä¸Šã€‚</li>
                    <li>å›åˆçµæŸï¼Œ<b>èµ·å§‹æ ¼è®Šç‚ºç©ºæ ¼</b>ã€‚</li>
                  </ul>
                </li>
                <li><b>å‹åˆ©æ¢ä»¶</b>:
                  <ul style="margin:8px 0 8px 16px; padding:0">
                    <li>è‹¥è¼ªåˆ°å°æ‰‹æ™‚æ²’æœ‰ä»»ä½•åˆæ³•è½é» â†’ ä½ ç²å¾—å‹åˆ©ã€‚</li>
                  </ul>
                </li>
          </ol>
        </div>
        <div class="rules" id="about" style="display:none">
          <h3 style="margin:0 0 8px">éŠæˆ²ä»‹ç´¹</h3>
          <p>æ­¤éŠæˆ²ä¾†æºæ–¼IGç²‰å°ˆ<b>celine.et.sasha</b>çš„reelå½±ç‰‡<b>IdÃ©e de jeu avec les cartes UNO ! ğŸ˜‰</b>ä¸­æ‰€å¾—çŸ¥çš„éŠæˆ²ï¼Œä½†å…·é«”è¨­è¨ˆè€…ä¸å¯è€ƒï¼ŒéŠæˆ²åç¨±ä¹Ÿæ˜¯æˆ‘è‡ªå·±å–çš„ï¼Œæˆ‘å€‹äººéå¸¸å–œæ­¡æ­¤éŠæˆ²ï¼Œå› æ­¤åšæˆç¶²é ç‰ˆåˆ†äº«çµ¦å¤§å®¶ã€‚</p>
          <p>ä¾†æºé€£çµï¼š<a href="https://www.instagram.com/reel/DM0XE8Mo41a/?igsh=MXJic2dpODF4NndxdA==" target="_blank" rel="noopener">Four-Moves-Chess</a></p>
        </div>
      </div>

      <div class="footer">å¥§ç¾…æ¡ŒéŠè¨­è¨ˆå·¥ä½œå®¤-ç¨‹å¼ç·´ç¿’ä½œå“</div>
    </div>
  </div>

  <script>
    // ====== éŠæˆ²è³‡æ–™çµæ§‹ ======
    const DIRS = { U:[-1,0], D:[1,0], L:[0,-1], R:[0,1] };
    const TILE_SR = 'SR', TILE_SB = 'SB';

    function deepCopyBoard(board){ return board.map(row=>row.map(c=>({tile:c.tile, covered:c.covered}))); }

    class GameJS{
      constructor(board, redPos, bluePos, turn='R'){
        this.board = board; // 4x4 of {tile, covered}
        this.redPos = redPos; // [r,c]
        this.bluePos = bluePos;
        this.turn = turn; // 'R' or 'B'
      }
      static fromRandom(){
        const tiles = [1,1,1,1,2,2,2,2,3,3,3,3,4,4,TILE_SR,TILE_SB];
        for(let i=tiles.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [tiles[i],tiles[j]]=[tiles[j],tiles[i]]; }
        const board=[]; let red=null, blue=null;
        for(let r=0;r<4;r++){
          const row=[];
          for(let c=0;c<4;c++){
            const t = tiles[r*4+c];
            row.push({tile:t, covered:false});
            if(t===TILE_SR) red=[r,c];
            if(t===TILE_SB) blue=[r,c];
          }
          board.push(row);
        }
        return new GameJS(board, red, blue, 'R');
      }
      static fromFixed(text, turn='R'){
        const lines = text.trim().split(/\n+/).slice(0,4);
        if(lines.length!==4) throw new Error('å›ºå®šç›¤é¢éœ€ 4 è¡Œ');
        const grid=[]; let red=null, blue=null, sr=null, sb=null;
        function parseToken(tok){
          tok = tok.trim().toUpperCase();
          if(tok==='X') return {tile:1, covered:true};
          if(tok==='SR'){ return {tile:TILE_SR, covered:false}; }
          if(tok==='SB'){ return {tile:TILE_SB, covered:false}; }
          if(/^R[1234]$/.test(tok)){ const n=Number(tok[1]); return {tile:n, covered:false, _piece:'R'}; }
          if(/^B[1234]$/.test(tok)){ const n=Number(tok[1]); return {tile:n, covered:false, _piece:'B'}; }
          const n = Number(tok);
          if(![1,2,3,4].includes(n)) throw new Error('ç„¡æ•ˆçš„ç¬¦è™Ÿï¼š'+tok);
          return {tile:n, covered:false};
        }
        for(let r=0;r<4;r++){
          const tks = lines[r].trim().split(/\s+/);
          if(tks.length!==4) throw new Error('ç¬¬ '+(r+1)+' è¡Œä¸æ˜¯ 4 æ¬„');
          const row=tks.map(parseToken);
          grid.push(row);
        }
        for(let r=0;r<4;r++){
          for(let c=0;c<4;c++){
            const cell = grid[r][c];
            if(cell._piece==='R') red=[r,c];
            if(cell._piece==='B') blue=[r,c];
            if(cell.tile===TILE_SR) sr=[r,c];
            if(cell.tile===TILE_SB) sb=[r,c];
            if(cell._piece) delete cell._piece;
          }
        }
        if(!red){ if(sr) red=sr; }
        if(!blue){ if(sb) blue=sb; }
        if(!red||!blue) throw new Error('éœ€æä¾› R èˆ‡ B çš„èµ·å§‹ä½ç½®ï¼ˆå¯ç”¨ Rn/Bn æˆ– SR/SBï¼‰');
        return new GameJS(grid, red, blue, turn);
      }
      clone(){ return new GameJS(deepCopyBoard(this.board), [...this.redPos], [...this.bluePos], this.turn); }
      inBounds(r,c){ return r>=0&&r<4&&c>=0&&c<4; }
      isBlocked(r,c){ if(!this.inBounds(r,c)) return true; if(this.board[r][c].covered) return true; if(this.redPos[0]===r&&this.redPos[1]===c) return true; if(this.bluePos[0]===r&&this.bluePos[1]===c) return true; return false; }
      cell(r,c){ return this.board[r][c]; }
      currentPlayer(){ return this.turn; }
      posOf(p){ return p==='R'? this.redPos: this.bluePos; }
      requiredSteps(){
        const pos = this.posOf(this.turn); const cell=this.cell(pos[0],pos[1]);
        if(cell.tile===TILE_SR || cell.tile===TILE_SB) return [1,2,3,4];
        return [Number(cell.tile)];
      }
      stepJump(pos, dirKey){ const [dr,dc]=DIRS[dirKey]; let [r,c]=pos; r+=dr; c+=dc; while(this.inBounds(r,c)){ if(this.isBlocked(r,c)){ r+=dr; c+=dc; continue; } return [r,c]; } return null; }
      neighborsOne(pos){ const res=[]; for(const d of ['U','D','L','R']){ const nxt=this.stepJump(pos,d); if(nxt) res.push(nxt); } return res; }
      reachableTargets(){
        const start = this.posOf(this.turn); const stepsChoices = this.requiredSteps(); const results=new Set();
        const key=(rc)=> rc[0]+","+rc[1];
        const dfs=(cur, depth, maxDepth, visitedSet)=>{
          if(depth===maxDepth){ if(!this.isBlocked(cur[0],cur[1])) results.add(key(cur)); return; }
          for(const nxt of this.neighborsOne(cur)){
            const k=key(nxt); if(visitedSet.has(k)) continue; if(this.isBlocked(nxt[0],nxt[1])) continue; const ns=new Set(visitedSet); ns.add(k); dfs(nxt, depth+1, maxDepth, ns);
          }
        };
        const startKey=key(start); for(const k of stepsChoices){ const vis=new Set([startKey]); dfs(start, 0, k, vis); }
        results.delete(startKey);
        return Array.from(results).map(s=>s.split(',').map(Number));
      }
      isTerminal(){ return this.reachableTargets().length===0; }
      winner(){ if(!this.isTerminal()) return null; return this.turn==='R'? 'B':'R'; }
      applyMoveTo(dest){ const key=(rc)=> rc[0]+","+rc[1]; const valids=new Set(this.reachableTargets().map(key)); const dKey=key(dest); if(!valids.has(dKey)) throw new Error('éæ³•ç›®çš„åœ°');
        const cur = this.posOf(this.turn); this.cell(cur[0],cur[1]).covered = true;
        if(this.turn==='R') this.redPos=[dest[0],dest[1]]; else this.bluePos=[dest[0],dest[1]];
        this.turn = this.turn==='R'? 'B':'R';
      }
      possibleStepsStr(pos){ const cell=this.cell(pos[0],pos[1]); if(cell.tile===TILE_SR||cell.tile===TILE_SB) return '1~4'; return String(cell.tile); }
    }

    // ====== ç°¡æ˜“ MCTS ======
    class MCTS{
      constructor({iterations=2000, c_ucb=Math.SQRT2, rolloutMax=30}={}){
        this.iterations = iterations;
        this.c_ucb = c_ucb;
        this.rolloutMax = rolloutMax;
      }
      chooseWithStats(game){
        const t0 = performance.now();
        const root = { game: game.clone(), parent: null, move: null, children: [], untried: [...game.reachableTargets()], visits: 0, value: 0 };
        const rootPlayer = root.game.currentPlayer();
        if(root.untried.length===0 && root.children.length===0){
          return {dest:null, iters:0, ms:0, p:0.5, pAvg:0.5, bestV:0, totalV:0, childStats:[]};
        }
        for(let it=0; it<this.iterations; it++){
          let node = root;
          while(node.untried.length===0 && node.children.length>0){ node = this._uctSelect(node, rootPlayer); }
          if(node.untried.length>0){
            const i = Math.floor(Math.random()*node.untried.length);
            const dest = node.untried.splice(i,1)[0];
            const next = node.game.clone();
            next.applyMoveTo(dest);
            const child = { game: next, parent: node, move: dest, children: [], untried: next.reachableTargets(), visits: 0, value: 0 };
            node.children.push(child);
            node = child;
          }
          const reward = this._rollout(node.game, rootPlayer);
          while(node){ node.visits++; node.value += reward; node = node.parent; }
        }
        const totalV = root.children.reduce((s,ch)=>s+ch.visits,0) || 1;
        const best = root.children.reduce((a,b)=> (a.visits>b.visits? a:b));
        const p = best.visits>0 ? best.value/best.visits : 0.5;
        const pAvg = root.children.length ? (root.children.reduce((s,ch)=> s + (ch.visits>0? ch.value:0), 0) / totalV) : 0.5;
        const ms = performance.now()-t0;
        const childStats = root.children.map(ch=>({move:ch.move, visits:ch.visits, p: ch.visits>0? ch.value/ch.visits:0.5})).sort((a,b)=>b.visits-a.visits);
        return {dest:best.move, iters:this.iterations, ms, p, pAvg, bestV:best.visits, totalV:totalV, childStats};
      }
      _uctSelect(node, rootPlayer){
        const lnN = Math.log(Math.max(1, node.visits));
        const parentTurnIsRoot = (node.game.currentPlayer()===rootPlayer);
        const unvisited = node.children.filter(ch=> ch.visits===0);
        if(unvisited.length>0){ return unvisited[Math.floor(Math.random()*unvisited.length)]; }
        let best=null, bestScore=-Infinity;
        for(const ch of node.children){
          const q = ch.value / ch.visits;
          const exploit = parentTurnIsRoot ? q : (1-q);
          const explore = this.c_ucb * Math.sqrt(lnN / ch.visits);
          const uct = exploit + explore;
          if(uct>bestScore){ bestScore=uct; best=ch; }
        }
        return best;
      }
      _rollout(startGame, rootPlayer){
        const g = startGame.clone();
        let steps=0;
        while(!g.isTerminal() && steps<this.rolloutMax){
          const moves=g.reachableTargets();
          if(moves.length===0) break;
          const dest = moves[Math.floor(Math.random()*moves.length)];
          g.applyMoveTo(dest);
          steps++;
        }
        const w = g.winner(); if(!w) return 0.5; return (w===rootPlayer? 1.0: 0.0);
      }
    }

    // ====== UI & äº’å‹• ======
    const elBoard = document.getElementById('board');
    const elLog = document.getElementById('log');
    const elRules = document.getElementById('rules');
    const elHint = document.getElementById('hint');
    const openingSel = document.getElementById('opening');
    const redTypeSel = document.getElementById('redType');
    const blueTypeSel = document.getElementById('blueType');
    const itersInput = document.getElementById('iters');
    const btnStart = document.getElementById('btnStart');
    const btnReset = document.getElementById('btnReset');

    // Tabs åˆ‡æ› (é€šç”¨å¯«æ³•)
    document.querySelectorAll('.tabs .tab').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        // ç§»é™¤æ‰€æœ‰ active
        document.querySelectorAll('.tabs .tab').forEach(b=>b.classList.remove('active'));
        // éš±è—æ‰€æœ‰å…§å®¹
        document.querySelectorAll('.tabwrap > div').forEach(div=>div.style.display='none');
        // å•Ÿç”¨è¢«é»æ“Šçš„
        btn.classList.add('active');
        document.getElementById(btn.dataset.target).style.display='block';
      });
    });

    // æ¨™æº–é–‹å±€ï¼ˆåŸæœ¬æŒ‡å®šé è¨­ï¼‰
    const STANDARD_TEXT = `1 2 3 4\n2 3 SB 1\n3 SR 1 2\n4 1 2 3`;
    // ä¿å­˜ç•¶å‰å±€çš„ã€Œåˆå§‹æ£‹ç›¤ã€æ–‡å­—ï¼ˆä¾›ç›¸åŒé–‹å±€ä½¿ç”¨ï¼‰
    let initialSnapshot = null;
    let game=null; let mcts=null; let ply=1; let waitingHuman=false; let pendingLegal=[]; let autoDelay=400;

    function logLine(html){ const p=document.createElement('p'); p.innerHTML=html; elLog.appendChild(p); elLog.scrollTop=elLog.scrollHeight; }

    function render(){
      elBoard.innerHTML='';
      const legalSet = new Set(pendingLegal.map(rc=>rc[0]+","+rc[1]));
      for(let r=0;r<4;r++){
        for(let c=0;c<4;c++){
          const d=document.createElement('div'); d.className='cell';
          let t='';
          const cell = game.board[r][c];
          if(cell.covered){ d.classList.add('X'); t=''; }
          else { const tile=cell.tile; t=(tile===TILE_SR||tile===TILE_SB)? 'S' : String(tile); }
          d.textContent = t;
          const turnNow = game.currentPlayer();
          if(game.redPos[0]===r && game.redPos[1]===c){ const pr=document.createElement('div'); pr.className='piece red'+(turnNow==='R'?' active':''); d.appendChild(pr); }
          if(game.bluePos[0]===r && game.bluePos[1]===c){ const pb=document.createElement('div'); pb.className='piece blue'+(turnNow==='B'?' active':''); d.appendChild(pb); }
          if(legalSet.has(r+","+c)) d.classList.add('legal');
          const coord=document.createElement('div'); coord.className='coords'; coord.textContent=`${r+1},${c+1}`; if(!cell.covered) d.appendChild(coord);
          d.addEventListener('click',()=>{ if(!waitingHuman) return; const key=r+","+c; if(!legalSet.has(key)) return; waitingHuman=false; moveTo([r,c]); });
          elBoard.appendChild(d);
        }
      }
      setBoardHintByTurn();
    }

    function computeLegal(){ pendingLegal = game.reachableTargets(); }

    function findPathTo(dest){
      const start = game.posOf(game.currentPlayer());
      const stepsChoices = game.requiredSteps();
      const key = (rc)=> rc[0]+','+rc[1];
      for(const maxDepth of stepsChoices){
        const q=[{pos:start, depth:0, path:[]}];
        const seen=new Set([key(start)+'|0']);
        while(q.length){
          const cur=q.shift();
          if(cur.depth===maxDepth){ if(cur.pos[0]===dest[0] && cur.pos[1]===dest[1]) return cur.path; continue; }
          for(const nxt of game.neighborsOne(cur.pos)){
            const k=key(nxt); if(cur.path.some(p=>p[0]===nxt[0]&&p[1]===nxt[1])) continue; const nkey=k+'|'+(cur.depth+1); if(seen.has(nkey)) continue; seen.add(nkey); q.push({pos:nxt, depth:cur.depth+1, path: cur.path.concat([nxt])});
          }
        }
      }
      return [dest];
    }

    function cellEl(r,c){ return elBoard.children[r*4 + c]; }
    function centerOfCell(r,c){ const ce=cellEl(r,c); const br=ce.getBoundingClientRect(); const pr=elBoard.getBoundingClientRect(); return {x: br.left-pr.left + br.width/2, y: br.top-pr.top + br.height/2, size: br.width*0.76}; }
    async function animateMove(dest){
      const who = game.currentPlayer();
      const start = game.posOf(who);
      const path = findPathTo(dest);
      if(!path || path.length===0){ return; }
      const startCell = cellEl(start[0], start[1]);
      const staticPiece = startCell.querySelector('.piece.'+(who==='R'?'red':'blue'));
      if(staticPiece) staticPiece.style.opacity = 0.25;
      const first = centerOfCell(start[0], start[1]);
      const ghost = document.createElement('div');
      ghost.className = 'anim-piece ' + (who==='R'?'red':'blue');
      ghost.style.width = ghost.style.height = first.size+'px';
      ghost.style.transform = `translate(${first.x - first.size/2}px, ${first.y - first.size/2}px)`;
      elBoard.appendChild(ghost);
      const stepMs = 250;
      for(const [r,c] of path){
        await new Promise(res=>{ requestAnimationFrame(()=>{ ghost.style.transition='transform '+stepMs+'ms ease'; const t=centerOfCell(r,c); ghost.style.transform = `translate(${t.x - t.size/2}px, ${t.y - t.size/2}px)`; setTimeout(res, stepMs); }); });
      }
      ghost.remove(); if(staticPiece) staticPiece.style.opacity = '';
    }

    async function moveTo(dest){
      try{ await animateMove(dest); game.applyMoveTo(dest); }catch(e){ logLine(`<span class='pill bad'>${e.message}</span>`); return; }
      ply++;
      computeLegal(); render();
      if(game.isTerminal()){
        render(); setBoardHintByTurn();
        updateWinrateBar();
        const loser = game.currentPlayer(); const winner = (loser==='R'?'B':'R');
        const loserPlayer = loser==='R' ? 'ç´…è‰²ç©å®¶' : 'è—è‰²ç©å®¶';
        const winnerPlayer = winner==='R' ? 'ç´…è‰²ç©å®¶' : 'è—è‰²ç©å®¶';
        logLine(`${loserPlayer}ç„¡æ³•ç§»å‹•ï¼Œ${winnerPlayer}å‹åˆ©`);
        return;
      }
      await maybeAuto();
    }

    function playerLabel(p){ return p==='R' ? 'ç´…è‰²ç©å®¶' : 'è—è‰²ç©å®¶'; }
    function logTurnHeader(){
      const who = game.currentPlayer();
      const whoLbl = playerLabel(who);
      const cls = (who==='R'?'t-red':'t-blue');
      logLine(`ç¬¬<b>${ply}</b>æ­¥ Â· ç¾åœ¨æ˜¯ <b class="${cls}">${whoLbl}</b> çš„å›åˆ`);
      updateWinrateBar();
    }
    function setBoardHintByTurn(){
      if(!elHint) return;
      if(game.isTerminal()){
        const loser=game.currentPlayer(); const winner=(loser==='R'?'B':'R');
        const loserPlayer = loser==='R'?'ç´…è‰²ç©å®¶':'è—è‰²ç©å®¶';
        const winnerPlayer = winner==='R'?'ç´…è‰²ç©å®¶':'è—è‰²ç©å®¶';
        elHint.textContent = `${loserPlayer}ç„¡æ³•ç§»å‹•ï¼Œ${winnerPlayer}å‹åˆ©`;
        return;
      }
      const who=game.currentPlayer();
      const whoPlayer = who==='R'?'ç´…è‰²ç©å®¶':'è—è‰²ç©å®¶';
      const role = (who==='R'? redTypeSel.value : blueTypeSel.value);
      if(role==='human') elHint.textContent = `${whoPlayer}è«‹é»æ“Šä»»ä¸€é«˜äº®æ ¼è½å­`;
      else if(role==='ai') elHint.textContent = `${whoPlayer}ç”±AIæ€è€ƒæ±ºå®šä¸­...`;
      else elHint.textContent = `${whoPlayer}ç”±éš¨æ©Ÿæ±ºå®šä¸­...`;
    }

    async function maybeAuto(){
      const actor = (game.currentPlayer()==='R'? redTypeSel.value : blueTypeSel.value);
      logTurnHeader();
      setBoardHintByTurn();
      if(actor==='human'){ computeLegal(); waitingHuman=true; render(); return; }
      computeLegal(); render();
      if(actor==='random'){
        await sleep(autoDelay);
        const legal = game.reachableTargets();
        const dest = legal[Math.floor(Math.random()*legal.length)];
        logLine(`éš¨æ©Ÿé¸æ“‡ <b>(${dest[0]+1}, ${dest[1]+1})</b>`);
        await moveTo(dest);
      } else if(actor==='ai'){
        if(!mcts) mcts = new MCTS({iterations: Number(itersInput.value)||1500, rolloutMax: 60});
        else mcts.iterations = Number(itersInput.value)||1500;
        logLine(`AIæ­£åœ¨æ€è€ƒä¸­...`);
        await sleep(0);
        const tStart = performance.now();
        const res = mcts.chooseWithStats(game);
        const elapsed = performance.now() - tStart;
        if (elapsed < autoDelay) { await sleep(autoDelay - elapsed); }
        if(!res.dest){ logLine(`AI ç„¡æ­¥å¯èµ°`); return; }
        logLine(`AIé¸æ“‡ <b>(${res.dest[0]+1}, ${res.dest[1]+1})</b> ï½œ å‹ç‡ <b>${(res.p*100).toFixed(1)}%</b>`);
        await moveTo(res.dest);
      }
    }

    function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

    function boardToText(g){
      const out=[];
      for(let r=0;r<4;r++){
        const row=[];
        for(let c=0;c<4;c++){
          const cell=g.board[r][c];
          if(cell.covered){ row.push('X'); }
          else if(cell.tile===TILE_SR){ row.push('SR'); }
          else if(cell.tile===TILE_SB){ row.push('SB'); }
          else { row.push(String(cell.tile)); }
        }
        out.push(row.join(' '));
      }
      return out.join('\n');
    }

    function startGame(){ try{
        const opening = openingSel.value; elLog.innerHTML=''; ply=1; waitingHuman=false; pendingLegal=[]; mcts=null; autoDelay=400;
        if(opening==='random'){
          game = GameJS.fromRandom();
        } else if(opening==='standard'){
          game = GameJS.fromFixed(STANDARD_TEXT, 'R');
        } else if(opening==='same'){
          if(initialSnapshot){ game = GameJS.fromFixed(initialSnapshot, 'R'); }
          else { game = GameJS.fromFixed(STANDARD_TEXT, 'R'); logLine(`<span class="pill">é¦–æ¬¡ä½¿ç”¨ã€Œç›¸åŒã€æ™‚ç„¡å¿«ç…§ï¼Œå·²æ”¹ç”¨æ¨™æº–é–‹å±€</span>`); }
        }
        game.turn='R';
        initialSnapshot = boardToText(game);
        computeLegal(); render();
        maybeAuto();
      }catch(err){ alert('åˆå§‹åŒ–å¤±æ•—ï¼š'+err.message); }
    }

    btnStart.addEventListener('click', startGame);
    btnReset.addEventListener('click', ()=>{ elLog.innerHTML=''; });

    // å‹ç‡æ¢æ›´æ–°
    function updateWinrateBar(){
      let red = 0.5, blue = 0.5;
      if(game && game.isTerminal()){
        if(game.winner()==='R'){ red=1; blue=0; }
        else if(game.winner()==='B'){ red=0; blue=1; }
      }else if(typeof MCTS==='function' && game){
        try{
          const m = new MCTS({iterations: 1500});
          const res = m.chooseWithStats(game);
          if(res && typeof res.p==='number'){
            if(game.currentPlayer()==='R'){ red=res.p; blue=1-res.p; }
            else{ blue=res.p; red=1-res.p; }
          }
        }catch(e){}
      }
      document.getElementById('barRed').style.width = (red*100)+'%';
      document.getElementById('barBlue').style.width = (blue*100)+'%';
      document.getElementById('redRate').textContent = `ç´…æ–¹å‹ç‡${(red*100).toFixed(1)}%`;
      document.getElementById('blueRate').textContent = `è—æ–¹å‹ç‡${(blue*100).toFixed(1)}%`;
    }

    // ===== Self-test (console) =====
    (function(){
      try{
        const g = GameJS.fromFixed(`1 2 3 4\n2 3 SB 1\n3 SR 1 2\n4 1 2 3`,'R');
        console.assert(g.currentPlayer()==='R','turn should be R');
        console.assert(g.requiredSteps().length===4,'SR gives 1~4');
        const targets=g.reachableTargets();
        console.assert(Array.isArray(targets) && targets.length>0,'has targets');
        const before=g.posOf('R');
        g.applyMoveTo(targets[0]);
        console.assert(g.cell(before[0],before[1]).covered===true,'leaving cell covered');
        console.assert(g.currentPlayer()==='B','turn switches to B');

        const g0 = GameJS.fromFixed(`1 2 3 4\n2 3 SB 1\n3 SR 1 2\n4 1 2 3`,'R');
        console.assert(boardToText(g0).trim()==='1 2 3 4\n2 3 SB 1\n3 SR 1 2\n4 1 2 3','boardToText standard snapshot');

        const gr = GameJS.fromRandom(); let cntSR=0,cntSB=0; for(let r=0;r<4;r++){ for(let c=0;c<4;c++){ const t=gr.board[r][c].tile; if(t===TILE_SR) cntSR++; if(t===TILE_SB) cntSB++; }}
        console.assert(cntSR===1 && cntSB===1,'random has exactly one SR and SB');

        const g2 = GameJS.fromFixed(`1 2 3 4\n2 3 SB 1\n3 SR 1 2\n4 1 2 3`,'R');
        let threw=false; try{ g2.applyMoveTo(g2.posOf('R')); }catch(e){ threw=true; }
        console.assert(threw,'applyMoveTo should throw on staying');

        const g3 = GameJS.fromFixed(`1 2 3 4\n2 3 SB 1\n3 SR 1 2\n4 1 2 3`,'R'); const t3=g3.reachableTargets()[0]; g3.applyMoveTo(t3); const snap3=boardToText(g3); console.assert(/\bX\b/.test(snap3),'snapshot after move contains X');

        console.log('[Self-test] OK');
      }catch(e){ console.error('[Self-test] FAIL', e); }
    })();

    // é¦–æ¬¡è¼‰å…¥å°±æº–å‚™ä¸€å±€
    startGame();
  </script>
<script>
// === ç­‰é«˜åŒæ­¥ï¼ˆåƒ…å½±éŸ¿é«˜åº¦ï¼Œä¸æ”¹ä»»ä½•ç¾æœ‰è¡Œç‚º/æ¨£å¼ï¼‰ ===
(function(){
  const app = document.querySelector('.app');
  const left = document.querySelector('.card.left');
  if(!app || !left) return;
  const apply = ()=>{
    // æ‰‹æ©Ÿä¸€æ¬„æ™‚ä¸å¼·åˆ¶ç­‰é«˜
    if (window.matchMedia('(max-width: 900px)').matches){
      app.style.removeProperty('--leftH');
      return;
    }
    const h = Math.round(left.getBoundingClientRect().height);
    app.style.setProperty('--leftH', h + 'px');
  };
  const ro = new ResizeObserver(apply);
  ro.observe(left);
  window.addEventListener('resize', apply, {passive:true});
  window.addEventListener('load', apply);
  apply();
})();
</script>
<img src="https://hits.sh/oro1081111.github.io/oro-games/FMG.html.svg?style=flat-square&label=" alt="" style="display:none">
</body>
</html>
