<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>四色棋 Four Color Chess</title>
  <style>
    :root{
      --bg: #0b1020;
      --panel: #121a33;
      --panel-2:#0f1530;
      --text: #e9eefb;
      --muted:#9fb0d6;
      --accent:#6ee7ff;
      --accent-2:#7c5cff;
      --good:#00d18f;
      --bad:#ff5c7c;
      --cell:#151f43;
      --cell-h:#1a2552;
      --cell-ring:#dff6ff;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 16px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, "Noto Sans TC", "PingFang TC", "Microsoft JhengHei", sans-serif;
      background: radial-gradient(1200px 800px at 20% -10%, #1b2352 0%, #0b1020 45%, #070a15 100%);
      color:var(--text);
      letter-spacing:.2px;
    }
    .app{max-width:1100px;margin:32px auto;padding:0 16px;display:grid;grid-template-columns: 1fr 1fr;gap:20px;align-items:stretch}
    .card{background:linear-gradient(180deg, var(--panel) 0%, var(--panel-2) 100%); border:1px solid #1f2a52;border-radius:var(--radius); box-shadow:var(--shadow); overflow:hidden; display:flex; flex-direction:column; height:100%;}
    .header{padding:18px 22px; display:flex; align-items:center; justify-content:space-between; border-bottom:1px solid #24305f}
    .header h1{font-size:20px;margin:0; font-weight:700; letter-spacing:.4px}
    .header .sub{opacity:.8;font-size:12px}

    .board-wrap{padding:20px}
    .board{display:grid; grid-template-columns: repeat(4, 1fr); gap:10px; position:relative}
    .cell{position:relative; aspect-ratio:1 / 1; background:var(--cell); border:1px solid #283569; border-radius:12px; display:flex; align-items:center; justify-content:center; font-weight:800; font-size:28px; color:#dbe6ff; transition:transform .08s ease, background .15s ease, border-color .2s ease;}
    .cell:hover{background:var(--cell-h)}
    .cell.legal{outline: 3px solid var(--cell-ring); outline-offset: -3px; cursor:pointer; box-shadow: 0 0 0 2px rgba(125,211,252,.3) inset}
    .coords{position:absolute; bottom:6px; right:8px; font-size:10px; color:#94a3b8; opacity:.6}

    /* === 亮色版棋盤（四色） === */
    .c-red{ background:#c34a5a; }
    .c-red:hover{ background:#d05566; }
    .c-blue{ background:#2e5fd1; }
    .c-blue:hover{ background:#3a6fee; }
    .c-yellow{ background:#c9a01a; }
    .c-yellow:hover{ background:#d6ad23; }
    .c-green{ background:#1ea371; }
    .c-green:hover{ background:#21b481; }

    /* 棋子（固定自帶顏色，不再受格色影響） */
    .piece{position:absolute; inset:12%; border-radius:50%; border:6px solid currentColor; background:transparent; box-shadow: 0 6px 16px rgba(0,0,0,.35), 0 0 0 2px rgba(255,255,255,0.10) inset; pointer-events:none; display:flex; align-items:center; justify-content:center;}
    .ownerB{ color:#000; } /* 黑框 */
    .ownerW{ color:#fff; } /* 白框 */
    .piece.p-red{ background:#ff6b6b; }
.piece.p-blue{ background:#58a6ff; }
.piece.p-yellow{ background:#ffd166; }
.piece.p-green{ background:#2dd4a7; }
    .focus-dot{ position:absolute; width:40%; height:40%; border-radius:50%; background:#5e0a86; top:30%; left:30%; }

    .panel{padding:16px 18px}
    .grid2{display:grid; grid-template-columns:1fr 1fr; gap:12px}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .row.nowrap{flex-wrap:nowrap}
    label{font-size:12px; color:var(--muted)}
    select,input,textarea,button{background:#0e1430; color:var(--text); border:1px solid #273163; border-radius:10px; padding:8px 10px; font-size:14px}
    input[type="number"]{width:120px}
    textarea{width:100%; height:110px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;}
    button{cursor:pointer; border:1px solid #394685; background:linear-gradient(180deg,#1a244e,#121a33); padding:10px 14px; font-weight:700}
    button.primary{background:linear-gradient(180deg, #2a76ff, #2356ce); border-color:#2d5fd1}
    button.ghost{background:transparent}

    .tabs{padding:10px 18px; display:flex; gap:10px; border-top:1px solid #24305f; background:#0a0f25}
    .tab{padding:8px 14px; border-radius:999px; border:1px solid #2b396e; background:#0b1333; color:#dbe6ff; cursor:pointer}
    .tab.active{background:#1b2a5a; border-color:#3a57a5}
    .tabwrap{flex:1 1 auto; display:flex; min-height:0}
    .log{padding:14px 18px; overflow:auto; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; background:#0a0f25; border-top:1px solid #24305f; border-bottom-left-radius:var(--radius); border-bottom-right-radius:var(--radius); flex:1 1 auto; min-height:0; height:auto}
    .log p{margin:6px 0}
    .rules{padding:16px 18px; overflow:auto; background:#0a0f25; border-top:1px solid #24305f; border-bottom-left-radius:var(--radius); border-bottom-right-radius:var(--radius); font-family: inherit; line-height:1.6; flex:1 1 auto; min-height:0; height:auto}

    .hint{font-size:12px; color:var(--muted); padding:0 18px 16px}
    .sep{height:1px;background:#24305f;margin:14px 0}
    .footer{padding:12px 18px; font-size:12px; color:#99a4c7; margin-top:auto}
  
    /* ===== Responsive ===== */
    .app{display:grid; grid-template-columns: 1.2fr 450px; gap:16px; max-width:1200px; margin:0 auto; padding: max(12px, env(safe-area-inset-top)) 12px 12px 12px;}
    @media (max-width: 900px){ .app{ grid-template-columns:1fr; } .right{ order:2; } .left{ order:1; } .panel{ width:100%; } }
    .board{ max-width: min(92vw, 560px); margin:0 auto; position:relative; }
    .cell{ aspect-ratio: 1 / 1; font-size: clamp(16px, 6vw, 28px); }
    .piece{ border-width: clamp(4px, 1vw, 6px); }
    @media (max-width: 420px){ .board{ gap:8px; } .cell .coords{ display:none; } }
    .right .card{ max-width:680px; margin:0 auto; }
    .right textarea{ width:100%; min-height:120px; font-size:16px; }
    .right select, .right input, .right button{ font-size:16px; }
    #log{ max-height:none; overflow:auto; }
    .board{ touch-action: manipulation; }
    /* 等高設定：右側高度跟隨左側（桌機） */
    .card.right{ height: var(--leftH, auto); }
    @media (max-width: 900px){ .card.right{ height:auto; } }
  </style>
  <style>
    a { color: #6ee7ff; text-decoration: underline; }
    a:hover { color: #fff; }
  </style>
</head>
<body>
  <div class="app">
    <div class="card left">
      <div class="header">
        <h1>四色棋 Four Color Chess</h1>
        <div class="sub">設計者：奧羅</div>
      </div>
      <div class="board-wrap">
        <!-- 勝率條 -->
        <div class="winrate-bar" style="margin:0 0 8px 0;">
          <div class="bar" style="display:flex;height:18px;border-radius:8px;overflow:hidden;background:#1a2a1a;border:1px solid #fff;">
            <div id="barBlack" style="background:#222;height:100%;transition:width .3s"></div>
            <div id="barWhite" style="background:#e9eefb;height:100%;transition:width .3s"></div>
          </div>
          <div class="labels" style="display:flex;justify-content:space-between;font-size:13px;margin-top:2px;">
            <span id="blackRate" style="color:#222">黑方勝率50%</span>
            <span id="whiteRate" style="color:#e9eefb">白方勝率50%</span>
          </div>
        </div>
        <div id="board" class="board"></div>
      </div>
      <div class="hint" id="hint">黑方先手：請點選任一黑方棋子以放置焦點</div>
    </div>

    <div class="card right">
      <div class="header">
        <h1>對局設定</h1>
        <div class="sub">玩家/隨機/AI、棋盤設置（標準/隨機/相同）</div>
      </div>
      <div class="panel">
        <div class="grid2">
          <div class="row">
            <label>黑方（先手）</label>
            <select id="blackType">
              <option value="human" selected>玩家</option>
              <option value="random">隨機</option>
              <option value="ai">AI</option>
            </select>
          </div>
          <div class="row">
            <label>白方（後手）</label>
            <select id="whiteType">
              <option value="human">玩家</option>
              <option value="random">隨機</option>
              <option value="ai" selected>AI</option>
            </select>
          </div>
          <div class="row">
            <label>棋盤設置</label>
            <select id="opening">
              <option value="standard" selected>標準</option>
              <option value="random">隨機</option>
              <option value="same">相同</option>
            </select>
          </div>
          <div class="row nowrap">
            <label for="iters">AI 迭代數</label>
            <input id="iters" type="number" min="200" step="200" value="2000" />
          </div>
        </div>
        <div class="sep"></div>
        <div class="row" style="gap:10px; justify-content:space-between">
          <button class="primary" id="btnStart">開始新對局</button>
          <button class="ghost" id="btnReset" onclick="window.location='index.html'">返回主頁</button>
        </div>
      </div>

      <!-- Tabs -->
      <div class="tabs">
        <button id="tabLog"   class="tab active" data-target="log">行動日誌</button>
        <button id="tabRules" class="tab"        data-target="rules">規則說明</button>
        <button id="tabAbout" class="tab"        data-target="about">遊戲介紹</button>
      </div>
      <div class="tabwrap">
        <div class="log" id="log"></div>
        <div class="rules" id="rules" style="display:none">
          <h3 style="margin:0 0 8px">遊戲規則</h3>
          <ol style="margin:0 0 8px 18px; padding:0">
            <li>黑方先手，需先把<b>紫色焦點棋</b>放在自己的任一棋子上，開始遊戲</li>
            <li><b>回合行動</b>：
                  <ul style="margin:8px 0 8px 16px; padding:0">
                    <li>擁有焦點棋的棋為本回合<b>必須移動</b>的棋子。</li>
                    <li>上下左右滑行至任一<b>空格</b>。</li>
                    <li>不可對角、不可跨越、停在任何棋子上。</li>
                    <li>移動後依落點<b>格色</b>，焦點棋將換到<b>對手相同顏色</b>的棋子上，並輪到對手行動。</li>
                  </ul>
            </li>
            <li><b>勝利條件</b>:
                  <ul style="margin:8px 0 8px 16px; padding:0">
                    <li>輪到對手時若被指定之棋<b>無合法步</b> → 你獲得勝利。</li>
                  </ul>
            </li>
          </ol>
        </div>
        <div class="rules" id="about" style="display:none">
          <h3 style="margin:0 0 8px">遊戲介紹</h3>
          <p>四色棋是由我自己(奧羅)設計的抽象棋類遊戲，也因為此遊戲可以自己跟自己對弈，因此我又稱之為邊緣棋。四色棋是我設計的第一個雙人棋類遊戲，雖然難以商業化，但是我個人非常喜歡這樣簡單乾淨的規則，同時此遊戲也是引導我開始製作機器學習與網頁設計的契機。</p>
          <p>關於此遊戲更多介紹：<a href="https://www.instagram.com/p/B5bsCvqla9f/?igsh=dGlyZndjbzR6ZGR3" target="_blank" rel="noopener">四色棋IG介紹貼文</a></p>
        </div>
      </div>

      <div class="footer">奧羅桌遊設計工作室 · 程式練習作品</div>
    </div>
  </div>

  <script>
    // ========== 核心規則引擎 ==========
    class FourColorChess {
      constructor(pattern){
        this.rows=4; this.cols=4;
        this.pattern = pattern || [
          ["red","blue","yellow","green"],
          ["blue","red","green","yellow"],
          ["yellow","green","red","blue"],
          ["green","yellow","blue","red"]
        ];
        this.pieces = { B:{}, W:{} };
        const top=0, bottom=3;
        for(let c=0;c<4;c++){
          const colTop = this.pattern[top][c];
          const colBot = this.pattern[bottom][c];
          this.pieces.W[colTop] = {r:0, c};
          this.pieces.B[colBot] = {r:3, c};
        }
        this.turn = 'B'; // 黑方先手
        this.focus = null; // {owner:'B'|'W', color:'red|blue|yellow|green'}
      }
      cellColor(r,c){ return this.pattern[r][c]; }
      inBounds(r,c){ return r>=0 && r<4 && c>=0 && c<4; }
      occupiedAt(r,c){
        for(const s of ['B','W']){
          for(const col of ['red','blue','yellow','green']){
            const p = this.pieces[s][col];
            if(p && p.r===r && p.c===c) return {side:s, color:col};
          }
        }
        return null;
      }
      pieceOf(owner,color){ return this.pieces[owner][color] || null; }

      tryPlaceInitialFocusOn(owner,color){
        if(this.focus) return false;
        if(this.turn!=='B') return false;
        if(owner!=='B') return false;
        const p = this.pieceOf(owner,color);
        return !!p ? (this.focus={owner,color}, true) : false;
      }

      legalMovesOf(owner,color){
        const p = this.pieceOf(owner,color);
        if(!p) return [];
        const res=[];
        const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
        for(const [dr,dc] of dirs){
          let r=p.r+dr, c=p.c+dc;
          while(this.inBounds(r,c)){
            if(this.occupiedAt(r,c)) break; // 不能越子/停在子上
            res.push([r,c]);
            r+=dr; c+=dc;
          }
        }
        return res;
      }
      legalMovesForFocus(){
        if(!this.focus) return [];
        if(this.focus.owner!==this.turn) return [];
        return this.legalMovesOf(this.focus.owner, this.focus.color);
      }

      isTerminal(){
        if(!this.focus) return false; // 未放焦點不算終局
        if(this.focus.owner!==this.turn) return false;
        return this.legalMovesForFocus().length===0;
      }
      winner(){
        if(!this.isTerminal()) return null;
        return this.turn==='B' ? 'W' : 'B';
      }

      applyMove(dest){
        if(!this.focus || this.focus.owner!==this.turn) throw new Error('不是該焦點/該回合');
        const legals = this.legalMovesForFocus().map(rc=>rc.join(','));
        if(!legals.includes(dest.join(','))) throw new Error('非法落點');
        const mover = this.pieceOf(this.focus.owner, this.focus.color);
        mover.r = dest[0]; mover.c = dest[1];
        const nextOwner = (this.turn==='B'?'W':'B');
        const landedColor = this.cellColor(dest[0], dest[1]);
        this.turn = nextOwner;
        this.focus = { owner: nextOwner, color: landedColor };
      }

      clone(){
        const cp = new FourColorChess(this.pattern.map(row=>row.slice()));
        cp.turn = this.turn;
        cp.focus = this.focus ? {...this.focus} : null;
        for(const s of ['B','W']){
          for(const col of ['red','blue','yellow','green']){
            cp.pieces[s][col] = {...this.pieces[s][col]};
          }
        }
        return cp;
      }
    }
    

    // ========== 產生隨機四色拉丁矩陣 ==========
    function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }
    function makeRandomLatin(){
      const colors=['red','blue','yellow','green'];
      const sym = shuffle(colors.slice());
      // 基本循環方陣
      const base=[
        [sym[0],sym[1],sym[2],sym[3]],
        [sym[1],sym[2],sym[3],sym[0]],
        [sym[2],sym[3],sym[0],sym[1]],
        [sym[3],sym[0],sym[1],sym[2]]
      ];
      // 隨機打亂列與欄的順序（保持拉丁性）
      const rp = shuffle([0,1,2,3]);
      const cp = shuffle([0,1,2,3]);
      const out=[ [null,null,null,null],[null,null,null,null],[null,null,null,null],[null,null,null,null] ];
      for(let i=0;i<4;i++) for(let j=0;j<4;j++) out[rp[i]][cp[j]] = base[i][j];
      return out;
    }

    // ========== MCTS ==========
    class MCTS {
      constructor({iterations=1500, c=Math.SQRT2}={}){ this.iterations=iterations; this.c=c; }
      actions(state){
        if(!state.focus && state.turn==='B'){
          const colors=['red','blue','yellow','green'];
          const choices=[];
          for(const col of colors){
            const p = state.pieceOf('B',col);
            if(!p) continue;
            const tmp = state.clone();
            tmp.tryPlaceInitialFocusOn('B',col);
            if(tmp.legalMovesForFocus().length>0) choices.push({type:'placeFocus', color:col});
          }
          return choices;
        }
        return state.legalMovesForFocus().map(rc=>({type:'move', dest:rc}));
      }
      step(state, action){
        const s = state.clone();
        if(action.type==='placeFocus'){ s.tryPlaceInitialFocusOn('B', action.color); return s; }
        s.applyMove(action.dest); return s;
      }
      rollout(state, rootPlayer, limit=60){
        let s = state.clone(); let steps=0;
        while(steps<limit){
          if(s.isTerminal()) break;
          const acts = this.actions(s);
          if(acts.length===0) break;
          const a = acts[Math.floor(Math.random()*acts.length)];
          s = this.step(s, a); steps++;
        }
        const w = s.winner(); if(!w) return 0.5; return (w===rootPlayer?1:0);
      }
      uctSelect(node, rootPlayer){
        let best = null;
        let bestScore = -Infinity;
        const isRootPlayer = node.state.turn === rootPlayer;
        for(const ch of node.children){
          const q = ch.value / Math.max(1,ch.visits);
          const exploit = isRootPlayer ? q : (1 - q);
          const u = this.c * Math.sqrt(Math.log(Math.max(1,node.visits)) / Math.max(1,ch.visits));
          const score = exploit + u;
          if(score > bestScore){
            bestScore = score;
            best = ch;
          }
        }
        return best;
      }
      choose(state){
        const root = {state:state.clone(), parent:null, action:null, children:[], unexpanded:this.actions(state), visits:0, value:0};
        const rootPlayer = state.turn;
        if(root.unexpanded.length===0 && root.children.length===0) return null;
        for(let i=0;i<this.iterations;i++){
          let node=root;
          while(node.unexpanded.length===0 && node.children.length>0){ node = this.uctSelect(node, rootPlayer); }
          if(node.unexpanded.length>0){
            const idx = Math.floor(Math.random()*node.unexpanded.length);
            const action = node.unexpanded.splice(idx,1)[0];
            const nextState = this.step(node.state, action);
            const child = {state:nextState, parent:node, action, children:[], unexpanded:this.actions(nextState), visits:0, value:0};
            node.children.push(child); node=child;
          }
          const reward = this.rollout(node.state, rootPlayer);
          while(node){ node.visits++; node.value += reward; node = node.parent; }
        }
        if(root.children.length===0) return null;
        root.children.sort((a,b)=>b.visits-a.visits);
        const best = root.children[0];
        let winrate = 0;
        if (best.visits > 0) {
          winrate = best.value / best.visits;
        }
        return {...best.action, winrate};
      }
    }

    // ========== UI ==========
    const elBoard = document.getElementById('board');
    const elLog   = document.getElementById('log');
    const elHint  = document.getElementById('hint');
    const blackTypeSel = document.getElementById('blackType');
    const whiteTypeSel = document.getElementById('whiteType');
    const openingSel   = document.getElementById('opening');
    const itersInput   = document.getElementById('iters');
    const btnStart = document.getElementById('btnStart');
    const btnReset = document.getElementById('btnReset');

    document.querySelectorAll('.tabs .tab').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        document.querySelectorAll('.tabs .tab').forEach(b=>b.classList.remove('active'));
        document.querySelectorAll('.tabwrap > div').forEach(div=>div.style.display='none');
        btn.classList.add('active');
        document.getElementById(btn.dataset.target).style.display='block';
      });
    });

let G=null, M=null; let waitingHuman=false; let legalNow=[]; let initialPatternSnapshot=null;
let stepCount = 0; // 步數計數

function logLine(html){ const p=document.createElement('p'); p.innerHTML=html; elLog.appendChild(p); elLog.scrollTop=elLog.scrollHeight; }
function playerLabel(id){ return id==='B' ? '黑方' : '白方'; }
function colorZh(c){ return ({red:'紅',blue:'藍',yellow:'黃',green:'綠'})[c] || c; }

function logStepHeader() {
  if (!G || !G.focus) return;
  logLine(`第${stepCount}步，現在輪到 ${playerLabel(G.turn)}${colorZh(G.focus.color)}棋移動`);
  updateWinrateBar();
}

function setHint(){
      if(!G){ elHint.textContent=''; return; }
      if(!G.focus && G.turn==='B'){ elHint.textContent = '黑方先手：請點選任一黑方棋子以放置焦點'; return; }
      if(G.isTerminal()){
        const w = G.winner(); const loser = (w==='B'?'白方':'黑方');
        elHint.textContent = `${loser}無合法步，${playerLabel(w)}勝利`; return;
      }
      const who = playerLabel(G.turn);
      const fc = G.focus ? colorZh(G.focus.color) : '（未放焦點）';
      const role = (G.turn==='B'? blackTypeSel.value : whiteTypeSel.value);
      if(!G.focus && G.turn==='B'){ elHint.textContent = `黑方請先放焦點`; }
      else if(role==='human'){ elHint.textContent = `${who}行動中，必須移動${fc}棋，請點擊高亮格移動`; }
      else if(role==='ai'){ elHint.textContent = `${who} AI 思考中…`; }
      else { elHint.textContent = `${who} 隨機 決定中…`; }
    }

    function pieceNode(occ){
      const piece = document.createElement('div');
      piece.className = `piece ${occ.side==='B'?'ownerB':'ownerW'} p-${occ.color}`; // 直接填色
      if(G.focus && G.focus.owner===occ.side && G.focus.color===occ.color){
        const f = document.createElement('div'); f.className='focus-dot'; piece.appendChild(f);
      }
      return piece;
    }

    function render(){
      elBoard.innerHTML='';
      const legalSet = new Set(legalNow.map(rc=>rc.join(',')));
      for(let r=0;r<4;r++){
        for(let c=0;c<4;c++){
          const col = G.cellColor(r,c);
          const d = document.createElement('div');
          d.className = `cell c-${col}`;
          if(legalSet.has([r,c].join(','))) d.classList.add('legal');

          const occ = G.occupiedAt(r,c);
          if(occ){
            d.appendChild(pieceNode(occ));
            d.addEventListener('click', ()=>{
              if(G.turn==='B' && !G.focus){
                if(occ.side!=='B') return;
                if(!G.tryPlaceInitialFocusOn('B', occ.color)) return;
                logLine(`黑方放置焦點於 <b>黑方${colorZh(occ.color)}棋</b>`);
                computeLegal(); render(); maybeAuto();
              }
            });
          }

          d.addEventListener('click', ()=>{
            if(!waitingHuman) return; const key=[r,c].join(','); if(!legalSet.has(key)) return; waitingHuman=false; doMove([r,c]);
          });

          const coord=document.createElement('div'); coord.className='coords'; coord.textContent=`${r+1},${c+1}`; d.appendChild(coord);
          elBoard.appendChild(d);
        }
      }
      setHint();
      updateWinrateBar();
    }

    function computeLegal(){ if(!G.focus){ legalNow=[]; return; } legalNow = (G.turn===G.focus.owner) ? G.legalMovesForFocus() : []; }

    function cellEl(r,c){ return elBoard.children[r*4 + c]; }
    function centerOfCell(r,c){
      const ce=cellEl(r,c);
      const br=ce.getBoundingClientRect();
      const pr=elBoard.getBoundingClientRect();
      return { x: br.left-pr.left + br.width/2, y: br.top-pr.top + br.height/2, size: br.width*0.76 };
    }
    function makeGhost(owner, color, withFocus){
      const div=document.createElement('div');
      div.className=`piece ${owner==='B'?'ownerB':'ownerW'} p-${color}`; // 幽靈同樣直接填色
      if(withFocus){ const f=document.createElement('div'); f.className='focus-dot'; div.appendChild(f); }
      div.style.position='absolute'; div.style.inset='auto'; div.style.pointerEvents='none';
      return div;
    }
    async function animateMoveFocus(dest){
      if(!G || !G.focus) return;
      const owner = G.focus.owner, color = G.focus.color;
      const p = G.pieceOf(owner, color);
      const start=[p.r,p.c];
      const startCell = cellEl(start[0], start[1]);
      const staticPiece = startCell.querySelector('.piece');

      const s = centerOfCell(start[0], start[1]);
      const d = centerOfCell(dest[0], dest[1]);
      const ghost = makeGhost(owner, color, true);
      ghost.style.width=ghost.style.height=s.size+'px';
      ghost.style.transform=`translate(${s.x - s.size/2}px, ${s.y - s.size/2}px)`;
      elBoard.appendChild(ghost);
      if(staticPiece) staticPiece.style.opacity = 0.25;

      await new Promise(r=>requestAnimationFrame(r));
      ghost.style.transition='transform 260ms ease';
      ghost.style.transform=`translate(${d.x - d.size/2}px, ${d.y - d.size/2}px)`;
      await new Promise(r=>setTimeout(r, 260));

      ghost.remove(); if(staticPiece) staticPiece.style.opacity='';
    }

async function doMove(dest, byAI = false, aiInfo = null){
  try{
    await animateMoveFocus(dest);   // 平滑動畫
    G.applyMove(dest);              // 更新狀態
  }catch(e){
    logLine(`<span class="pill bad">非法：${e.message}</span>`);
    waitingHuman=false; computeLegal(); render(); return;
  }
  stepCount++;
  if (byAI) {
    if (aiInfo && typeof aiInfo.winrate === 'number') {
      logLine(`AI ${playerLabel(G.turn === 'B' ? 'W' : 'B')}選擇 (${dest[0]+1}, ${dest[1]+1}) ${colorZh(G.cellColor(dest[0],dest[1]))}格 | ${playerLabel(G.turn === 'B' ? 'W' : 'B')}勝率${(aiInfo.winrate*100).toFixed(1)}%`);
    } else {
      logLine(`AI選擇 (${dest[0]+1}, ${dest[1]+1}) ${colorZh(G.cellColor(dest[0],dest[1]))}格`);
    }
  } else {
    logLine(`玩家選擇 (${dest[0]+1}, ${dest[1]+1}) ${colorZh(G.cellColor(dest[0],dest[1]))}格`);
  }
  logLine(`焦點切換至 ${playerLabel(G.turn)}${colorZh(G.focus.color)}棋`);
  if(G.isTerminal()){
    const w = G.winner();
    const loser = (w==='B'?'白方':'黑方');
    logLine(`${loser}無法合法移動，${playerLabel(w)}勝利`);
    updateWinrateBar();
    }
  computeLegal(); render(); await maybeAuto();
}

    function logTurnHeader(){ const who = playerLabel(G.turn); const fc = G.focus ? colorZh(G.focus.color) : '未放焦點'; logLine(`— 現在輪到 ${who}回合（焦點：${fc}）—`); }

async function maybeAuto(){
  const role = (G.turn==='B'? blackTypeSel.value : whiteTypeSel.value);
  setHint(); if(G.isTerminal()){ render(); return; }
  if(role==='human'){
    if(!G.focus && G.turn==='B'){ waitingHuman=false; computeLegal(); render(); return; }
    computeLegal(); waitingHuman=true; render(); return;
  }
  logStepHeader();
  if(role==='ai'){ logLine('AI正在思考中...'); }
  await sleep(250);
  if(!G.focus && G.turn==='B'){
    const cols=['red','blue','yellow','green'];
    const candidates = cols.filter(c=>{ const tmp=G.clone(); tmp.tryPlaceInitialFocusOn('B',c); return tmp.legalMovesForFocus().length>0; });
    if(candidates.length===0){ logLine(`<span class="pill bad">黑方無可行焦點與著法，白方勝利</span>`); render(); return; }
    let chooseCol;
    if(role==='random'){ chooseCol = candidates[Math.floor(Math.random()*candidates.length)]; }
    else { const act = chooseByMCTS(G); chooseCol = (act && act.type==='placeFocus')? act.color : candidates[0]; }
    G.tryPlaceInitialFocusOn('B', chooseCol); logLine(`黑方放置焦點於 黑方${colorZh(chooseCol)}棋`);
  }
  let dest=null, aiInfo=null;
  if(role==='random'){ const leg=G.legalMovesForFocus(); dest = leg[Math.floor(Math.random()*leg.length)]; }
  else { 
    const act = chooseByMCTS(G); 
    if(act && act.type==='move') {
      dest=act.dest;
      if (role==='ai' && typeof act.winrate === 'number') aiInfo = {winrate: act.winrate};
    }
  }
  if(!dest){ logLine(`<span class="pill bad">${playerLabel(G.turn)}無路可走</span>`); render(); return; }
  await sleep(150); await doMove(dest, role==='ai', aiInfo);
}

    function chooseByMCTS(state){ const m = M || (M=new MCTS({iterations: Math.max(200, Number(itersInput.value)||2000)})); m.iterations = Math.max(200, Number(itersInput.value)||2000); return m.choose(state); }
    function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

function startGame(){
  elLog.innerHTML=''; M=null; waitingHuman=false; legalNow=[]; stepCount = 0;
  // 依棋盤設置建立 pattern
  const mode = openingSel.value;
  let pattern;
  if(mode==='standard'){
    pattern = [
      ["red","blue","yellow","green"],
      ["blue","red","green","yellow"],
      ["yellow","green","red","blue"],
      ["green","yellow","blue","red"]
    ];
  }else if(mode==='random'){
    pattern = makeRandomLatin();
  }else{ // same
    if(initialPatternSnapshot) pattern = initialPatternSnapshot.map(row=>row.slice());
    else {
      pattern = [
        ["red","blue","yellow","green"],
        ["blue","red","green","yellow"],
        ["yellow","green","red","blue"],
        ["green","yellow","blue","red"]
      ];
      logLine('<span class="pill">首次使用「相同」時無快照，已改用標準棋盤</span>');
    }
  }
  G = new FourColorChess(pattern);
  initialPatternSnapshot = pattern.map(row=>row.slice());
  logLine('新對局開始 · 黑方先手');
  computeLegal(); render(); maybeAuto();
}

    btnStart.addEventListener('click', startGame);
    btnReset.addEventListener('click', ()=>{ elLog.innerHTML=''; });

function updateWinrateBar(){
  let black = 0.5, white = 0.5;
  if(G && G.isTerminal()){
    if(G.winner()==='B'){ black=1; white=0; }
    else if(G.winner()==='W'){ black=0; white=1; }
  }else if(typeof MCTS==='function' && G){
    try{
      const m = new MCTS({iterations: 1500});
      // 若 G.focus 尚未設，複製 G 並隨機設一個可用焦點
      let gTest = G;
      if(!G.focus && G.turn==='B'){
        const colors=['red','blue','yellow','green'];
        for(const col of colors){
          const tmp = G.clone();
          if(tmp.tryPlaceInitialFocusOn('B',col) && tmp.legalMovesForFocus().length>0){
            gTest = tmp; break;
          }
        }
      }
      const res = m.choose(gTest);
      if(res && typeof res.winrate==='number'){
        if(gTest.turn==='B'){ black=res.winrate; white=1-res.winrate; }
        else{ white=res.winrate; black=1-res.winrate; }
      }
    }catch(e){}
  }
  document.getElementById('barBlack').style.width = (black*100)+'%';
  document.getElementById('barWhite').style.width = (white*100)+'%';
  document.getElementById('blackRate').innerHTML = `<span style="color:#81848A">黑方勝率${(black*100).toFixed(1)}%</span>`;
  document.getElementById('whiteRate').textContent = `白方勝率${(white*100).toFixed(1)}%`;
}

    // 等高同步（右欄跟左欄）
    (function(){
      const app = document.querySelector('.app');
      const left = document.querySelector('.card.left');
      if(!app || !left) return;
      const apply = ()=>{
        if (window.matchMedia('(max-width: 900px)').matches){ app.style.removeProperty('--leftH'); return; }
        const h = Math.round(left.getBoundingClientRect().height); app.style.setProperty('--leftH', h + 'px');
      };
      const ro = new ResizeObserver(apply);
      ro.observe(left);
      window.addEventListener('resize', apply, {passive:true});
      window.addEventListener('load', apply);
      apply();
    })();

    // 首次載入先準備一局
    startGame();
  </script>
</body>
</html>
